//! An object oriented approach to the gameloop, separate from [`fps_gameloop!`](crate::fps_gameloop). Read the [MainLoopRoot] documentation for more info

use std::time::{Duration, Instant};

/// This is an alternative way to handle the gameloop, separate from [`fps_gameloop!`](crate::fps_gameloop). It takes on a more object oriented approach where everything related to the game is stored inside a single struct which implements this trait. Let's take a closer look
pub trait MainLoopRoot {
    /// This type should be generated by [`MainLoopRoot::sleep_and_get_input_data()`] and will be passed to [`MainLoopRoot::frame()`]
    type InputDataType;

    #[warn(missing_docs)]
    fn frame(&mut self, input_data: Option<Self::InputDataType>);
    /// All rendering code (blitting, printing to the screen, etc.) should be called in here. If the bool value returned by [`MainLoopRoot::sleep_and_get_input_data()`] is true, this won't run and nothing should be printed to the screen
    fn render_frame(&mut self);

    /// The function used to sleep for the appropriate amount based on the FPS. Uses [`gameloop::sleep_fps`](super::sleep_fps) by default and will return None for the `InputDataType`. The returned bool value should represent whether or not to skip rendering on the next frame
    fn sleep_and_get_input_data(
        &self,
        fps: f32,
        elapsed: Duration,
    ) -> (bool, Option<Self::InputDataType>) {
        (super::sleep_fps(fps, Some(elapsed)), None)
    }

    /// The main loop function of the main loop root. This shouldnt be overriden. The `fps` parameter will be passed straight to [`sleep_and_get_input()`](MainLoopRoot::sleep_and_get_input_data()). See the [MainLoopRoot] documentation for more info
    /// ```
    /// # use gemini_engine::gameloop::MainLoopRoot;
    /// # struct Game {}
    /// # impl MainLoopRoot for Game {
    /// #   type InputDataType = u32;
    /// #   fn frame(&mut self, input_data: Option<Self::InputDataType>) {}
    /// #   fn render_frame(&mut self) {}
    /// # }
    /// const FPS: f32 = 30;
    /// let game = Game::new(); // Implements MainLoopRoot
    ///
    /// game.main_loop(FPS);
    /// ```
    fn main_loop(&mut self, fps: f32) {
        let mut elapsed = Duration::ZERO;

        loop {
            let (frame_skip, input_data) = self.sleep_and_get_input_data(fps, elapsed);
            let now = Instant::now();

            self.frame(input_data);

            if !frame_skip {
                self.render_frame();
            }

            elapsed = now.elapsed();
        }
    }
}
